Написать программный модуль на языке Си выполняющий функции динамического выделения памяти (без использования средств языка malloc и.т.п)
Модуль должен:
-Использовать статическую оперативную память (например 8192 байт), разбитую на блоки по 256 байт, 32 блока (общий пул)
-При запросе из вне выделять объект ("буффер"), отдавать наружу ссылку на него, в дальнейшем эта ссылка должна использоваться для обращения к этому буферу
-В указанном выше объекте должно хранится состояние этого "буфера"
-При запросе записи в этот "буффер" (по указанной выше ссылке) выделять незанятые блоки памяти из общего пула и последовательно записывать в них данные
-Позволять произвольно записывать данные в "буффер"
-Позволять последовательно читать данные из "буфера"
-Позволять произвольно читать данные из "буфера"
-Позволять вставлять данные произвольного размера в произвольное местов "буфере"
-Позволять освобождать буфер по ссылке
-Позволять работать одновременно с несколькими буферами

Функции взаимодействия с модулем:

//Выделение буфера
bool Get_Buffer(t_buf** buffer)

//Запись в буфер
bool Write_Buffer(t_buf* buffer, uint8_t* data, uint16_t size)
bool Write_Buffer_Position(t_buf* buffer, uint8_t* data, uint16_t size,  uint16_t position)

//Чтение из буфера
bool Read_Buffer(t_buf* buffer, uint8_t* data, uint16_t size)
bool Read_Buffer_Position(t_buf* buffer, uint8_t* data, uint16_t size,  uint16_t position)

//Вставка в буфер
bool Join_Buffer(t_buf* buffer, uint8_t* data, uint16_t size,  uint16_t position)

//Освобождение в буфера
bool Free_Buffer(t_buf* buffer)

В интернете существуют реализации подобных модулей допускается брать их за основу.

Для объяснения разлиций функций Write_Buffer и Join_Buffer_Position приведу нескольуо примеров:

рисунок 1 (красным - занятые блоки, зеленым свободные)
t_buf* first_buffer содержит строку "Hello_world!_I'm_first_buffer", и состоит из 4 блоков расположенных не последовательно,
т.к. при ее записи блок 2 был занят другим буфером. 

Первый случай:
При вызове Get_Buffer(t_buf** second_buffer), должена инициализироваться структура типа t_buf и ее адрес должен возвращаться в
аргументе second_buffer. В дальнейшем при записи Write_Buffer со ссылкой на second_buffer например строки "Это_зпись_во_второй_буфер"
запись должна осуществлятся сначала в 1,2-8 байты 2-го блока затем в 6-й блок и так далее. Результат на рисунке 2. 
Read_Buffer(first_buffer) должен возвращать - "Hello_world!_I'm_first_buffer"
Read_Buffer(second_buffer) должен возвращать - "Это_зпись_во_второй_буфер"

Второй случай:
При вызове Write_Buffer со ссылкой на first_buffer запись 
должна осуществлятся сначала в 6,7,8 байт 5-го блока затем в 6-й блок и так далее.

Третий случай:
При вызове Write_Buffer_Position со ссылкой на first_buffer и позицией например 14 запись 
должна осуществлятся начиная с 6-го байта 3-го блока.

Четвертый случай:
При вызове Write_Buffer_Position со ссылкой на first_buffer и позицией например 58 
должны зарезервироваться блоки 6,7,8, а запись должна осуществлятся начиная с 2-го байта 8-го блока, и если строка для записи 
была например "writed" память будет выглядесть как на рисунке 3.

Пятый случай:
При вызове Join_Buffer_Position со ссылкой на first_buffer и позицией например 14 с текстом "joined_"
должен зарезервироваться блок 2 в него должен записаться текст "joined_" апамять будет выглядесть как на рисунке 4, а результат чтения
из first_buffer:
Read_Buffer(first_buffer) должен возвращать "Hello_world!_joined_I'm_first_buffer"
